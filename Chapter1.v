(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(** * Chapter1

This file is a translation of Chapter1.thy as of 2015-01-15T16:27:06-05:00
(TODO: get the git version number or whatever). We only translate
the code, not the actual text of the chapter.
*)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)

Require Import Coq.Lists.List.
Require Import Coq.Lists.ListSet.
Require Import Coq.Arith.Max.
Require Import Coq.Arith.Peano_dec.
Require Import Coq.Arith.Le.
Require Import Coq.Arith.Lt.
Require Import Omega.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
Section Chapter1.

Section Primitive_Recursion_and_Structural_Induction.

(* N.B.,
- Coq's [:]      is like Isabelle's [::].
- Coq's [set_In] is like Isabelle's [:] aka [\<in>].
- Coq's [In] is similar, but for lists instead of sets.
- Coq's [::]     is like Isabelle's [#].
- Coq's [admit.] is like Isabelle's [sorry]
- Coq's [Abort.] is like Isabelle's [oops]
- Coq's [->]     is like *both* [==>] and [=>]
- Coq's [forall] is like *both* [ALL] aka [\<forall>] and [/\]
*)
Fixpoint repeat (f : nat -> nat) (n : nat) (x : nat) : nat :=
    match n with
    | 0    => x
    | S n' => repeat f n' (f x)
    end.
(* TODO: implement the notation similar to Isabelle's [("_^_ _" [90,90,90] 89)] *)


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
Section Mathematical_Induction.

Lemma repeat_add :
    forall f m n x,
    repeat f (m + n) x = repeat f n (repeat f m x).
Proof.
  (* Here we have to give the names in order to ensure that we do
     not introduce [x] just yet. We need to generalize the inductive
     hypothesis to abstract over [x], so we want to hold off on
     introducing [x] until after we call the [induction] tactic. *)
  intros f m n.
  
  induction m.
    (* case [m = 0] *)
    simpl.
    (* The [reflexivity] tactic is smart enough that we don't need
       to introduce [x] before using it. But we could introduce [x]
       first if we wanted to. *)
    reflexivity.
    
    (* case [m = S m'] *)
    simpl.
    (* Here, we have to introduce [x] before we can call [rewrite],
       since the [rewrite] tactic isn't quite so smart. We don't
       really need to give the name of the variable since we're not
       actually using it; but I'm providing it for clarity. *)
    intro x.
    (* Now we use our generalized inductive hypothesis. *)
    rewrite IHm.
    (* and finally we can conclude. *)
    reflexivity.
Qed.


(* Note, to improve the maintainability of our proofs, sometimes
   we want to be explicit about where the subproofs begin and end---
   more like how Isabelle does things. The syntax for doing that
   uses a semicolon followed by square brackets together with a
   pipe to separate the different subgoals. Note that within these
   brackets we can only use the semicolon to combine things, we
   can't use the period since periods only go at the very end of
   the line. *)
Lemma repeat_add_redux1 :
    forall f m n x,
    repeat f (m + n) x = repeat f n (repeat f m x).
Proof.
  intros f m n.
  induction m;
    [ simpl; reflexivity
    | simpl; intro x; rewrite IHm; reflexivity
    ].
Qed.


(* Whenever we do the same thing at the beginning of each branch,
   we can factor it out by using the semicolon. Whenever we use a
   semicolon like in [tactic1; tactic2.] what that means is that
   after running [tactic1] we should apply [tactic2] to *all* the
   subgoals generated by [tactic1]. If [tactic1] only creates a
   single subgoal, then there's no difference vs [tactic1. tactic2.].
   Here we're factoring out the simplification step. *)
Lemma repeat_add_redux2 :
    forall f m n x,
    repeat f (m + n) x = repeat f n (repeat f m x).
Proof.
  intros f m n.
  induction m; simpl;
    [ reflexivity
    | intro x; rewrite IHm; reflexivity
    ].
Qed.


(* We can also factor things out on the other side. Note that now
   we've ended up with a branch that doesn't have anything written
   in it! That's okay. *)
Lemma repeat_add_redux3 :
    forall f m n x,
    repeat f (m + n) x = repeat f n (repeat f m x).
Proof.
  intros f m n.
  induction m; simpl;
    [
    | intro x; rewrite IHm
    ]; reflexivity.
Qed.


(* Note that the above proofs of the main lemma use a somewhat
   different reasoning style than in the Isabelle proofs. In the
   Isabelle proofs we're introducing a whole bunch of equality
   hypotheses and then chaining them together; whereas in the Coq
   proof we're using equality hypotheses to rewrite the goal. The
   following proof more closely follows the Isabelle version. The
   [congruence] tactic is a solver for chaining together a bunch
   of equalities. *)
Lemma repeat_add_redux4 :
    forall f m n x,
    repeat f (m + n) x = repeat f n (repeat f m x).
Proof.
  intros f m n; induction m; intro x.
    (* case m = 0 *)
    assert (repeat f (0 + n) x = repeat f n x)
      by (simpl; reflexivity).
    assert (repeat f n x = repeat f n (repeat f 0 x))
      by (simpl; reflexivity).
    congruence.
    
    rename m into m'. (* undo Coq's renaming convention *)
    (* case m = S m' *)
    assert (repeat f (S m' + n) x = repeat f (m' + n) (f x))
      by (simpl; reflexivity).
    assert (repeat f (m' + n) (f x) = repeat f n (repeat f m' (f x)))
      by (apply IHm).
    assert (repeat f n (repeat f m' (f x)) = repeat f n (repeat f (S m') x))
      by (simpl; reflexivity).
    congruence.
Qed.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
Theorem repeat_cycle :
    forall {f n x} m,
    repeat f n x = x -> repeat f (m * n) x = x.
Proof.
  (* We don't actually need to give the names here since we're
     introducing everything, which is the behavior of [intros.] *)
  intros f n x m H.
  
  (* We perform induction on [m] and then simplify the multiplication
     based on our refinement of [m]. By using a semicolon instead
     of a period we run [simpl] on all of the branches generated
     by the [induction] tactic. Alternatively, we could call it
     separately in each subproof. *)
  induction m; simpl.
  
    (* case [m = 0] *)
    reflexivity.
    
    (* case [m = S m'] *)
    rewrite repeat_add.
    rewrite H. (* our original [H : repeat f n x = x] hypothesis. *)
    exact IHm. (* our inductive hypothesis for [m] *)
    (* Instead of using [exact], we could instead do [rewrite IHm. reflexivity.] if desired *)
Qed.


(* Again, we could more closely mimic the Isabelle proof by asserting
   various equalities and then using [congruence] at the end. *)

End Mathematical_Induction.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
Section Structural_Induction_on_Lists.

(* these two hypotheses will be treated as assumptions within this
   section, but once we close the section they will become abstracted
   out as the first two arguments to everything defined here. The
   fact that equality on [A] is decidable is something we need to
   explicitly mention and pass around proof of, unlike in Isabelle. *)
Variable A : Type.
Hypothesis eq_A_dec : forall x y:A, {x = y} + {x <> y}.


Fixpoint multirember (a : A) (bs : list A) : list A :=
    match bs with
    | nil      => nil
    | b :: bs' =>
        match eq_A_dec a b with
        | left  _ => multirember a bs'
        | right _ => b :: multirember a bs'
        end
    end.
    

(* This variant of the [multirember_not_member] lemma works directly
   on lists rather than passing through sets. In Coq, this version
   is much more straightforward to prove. *)
Lemma multirember_not_member__lists : forall a bs, ~In a (multirember a bs).
Proof.
  intros; induction bs; simpl;
    [ auto (* the goal here is [~False] which is trivial *)
    | destruct (eq_A_dec a a0); simpl;
      [ assumption (* the inductive hypothesis for [bs] *)
      | intro H; destruct H;
        [ congruence (* prove [False] from [a <> a0] and [a0 = a] *)
        | exact (IHbs H)
        ]
      ]
    ].
Qed.



(* I can't seem to find this in the libraries anywhere... *)
Fixpoint list_to_set (xs : list A) : set A :=
    match xs with
    | nil => empty_set A
    | x :: xs' => set_add eq_A_dec x (list_to_set xs')
    end.


Lemma set_In_stable_for_set_add
    : forall x y xs,
    x <> y -> set_In x (set_add eq_A_dec y xs) -> set_In x xs.
Proof.
  intros.
  induction xs; simpl in *;
    [ destruct H0; [congruence |]
    | destruct (eq_A_dec y a); simpl in *;
      [ | destruct H0; [ left | right; apply IHxs ]]
    ]; assumption.
Qed.
              

(* This version more closely matches the Isabelle version. *)
Lemma multirember_not_member__sets :
    forall a bs,
    ~set_In a (list_to_set (multirember a bs)).
Proof.
  intros.
  induction bs; simpl;
    [ auto
    | destruct (eq_A_dec a a0); simpl;
      [ assumption
      | intro H
      (* [exact (IHbs (set_In_stable_for_set_add a a0 _ n H))] *)
      ; apply IHbs
      ; eapply set_In_stable_for_set_add; eassumption
      ]
    ].
Qed.


(* Can't seem to find this in the libraries, but I'm sure it's there
   somewhere. *)
(* cf., [Coq.Arith.Lt.le_or_lt] *)
Fixpoint le_dec m n : {m <= n} + {n < m} :=
    match m, n with
    | 0   , 0    => left  _ (le_n 0)
    | 0   , S n' => left  _ (le_0_n (S n'))
    | S m', 0    => right _ (lt_0_Sn m')
    | S m', S n' =>
        match le_dec m' n' with
        | left  m'_le_n' => left  _ (le_n_S m' n' m'_le_n')
        | right n'_lt_m' => right _ (lt_n_S n' m' n'_lt_m')
        end
    end.

Definition lt_dec m n : {m < n} + {n <= m} :=
    match le_dec n m with
    | left  n_le_m => right _ n_le_m
    | right m_lt_n => left  _ m_lt_n
    end.


Fixpoint insert_sorted (x : nat) (ys : list nat) : list nat :=
    match ys with
    | nil      => x :: nil
    | y :: ys' =>
        if le_dec x y
        then x :: y :: ys'
        else y :: insert_sorted x ys'
    end.


(* This is the most natural way to phrase this in Coq. However,
   it's quite different from the Isabelle version since it uses
   [Prop] in lieu of [bool] and uses [In] in lieu of [set_In]. *)
Fixpoint Is_Sorted (xs : list nat) : Prop :=
    match xs with
    | nil      => True
    | x :: xs' => (forall y, In y xs' -> x <= y) /\ Is_Sorted xs'
    end.
    

End Structural_Induction_on_Lists.


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
Section Structural_Induction_on_Trees.


Inductive tree (A : Type) : Type :=
    | Leaf : tree A
    | Node : tree A -> A -> tree A -> tree A
    .
Implicit Arguments Node [A].


Fixpoint height {A} (t : tree A) : nat :=
    match t with
    | Leaf       => 0
    | Node L x R => 1 + max (height L) (height R)
    end.

Fixpoint leaves {A} (t : tree A) : nat :=
    match t with
    | Leaf       => 1
    | Node L x R => leaves L + leaves R
    end.
      

(* Why isn't this in the standard libraries? *)
Lemma max_le_sum: forall x y, max x y <= x + y.
Proof.
  intro x; induction x; simpl; intros.
    auto.
    
    case y; simpl.
      omega.
      
      intro z.
      apply le_n_S.
      (* Could also use [plus_comm] twice, instead of using [plus_Snm_nSm] *)
      rewrite <- plus_Snm_nSm.
      simpl.
      apply le_S.
      apply IHx.
Qed.


(* HACK: why isn't this already done in the standard library?! *)
Add Parametric Relation : nat le
    reflexivity  proved by le_n
    transitivity proved by le_trans
    as le_rel.


Theorem height_less_leaves
    : forall {A} (t : tree A), S (height t) <= leaves t.
Proof.
  intros A t; induction t as [ | t1 IHt1 a t2 IHt2]; simpl.
    (* case [Leaf] *)
    reflexivity.
    
    (* case [Node L x R]
       Translating the Isabelle literally: *)
    assert (H0: S(height (Node t1 a t2)) = S(S(max (height t1) (height t2))))
      by auto.
    assert (S(S(max (height t1) (height t2))) <= S(S(height t1 + height t2)))
      by (apply le_n_S; apply le_n_S; apply max_le_sum).
    assert (S(S(height t1 + height t2)) <= leaves t1 + leaves t2)
      by omega.
    assert (S (height (Node t1 a t2)) <= leaves (Node t1 a t2))
      by (rewrite H0; eapply le_trans; eauto).
    auto.
    
    (* More succinct/direct proof:
    transitivity (S (S (height t1 + height t2)));
      [ apply le_n_S; apply le_n_S; apply max_le_sum
      | omega ]. *)
Qed.


(* Again, this is the most natural way to do this in Coq, but it's
   very different from the Isabelle version since it uses [Prop]
   in lieu of [bool]. *)
Fixpoint isomorphic_tree {A} (t1 t2 : tree A) : Prop :=
    match t1 with
    | Leaf         => t2 = Leaf A
    | Node L1 x R1 =>
        match t2 with
        | Leaf         => False
        | Node L2 y R2 => isomorphic_tree L1 L2 /\ isomorphic_tree R1 R2
        end
    end.


Theorem thm1 : forall {A}, isomorphic_tree (Leaf A) (Leaf A).
Proof. simpl; auto. Qed.

Theorem thm2 :
    isomorphic_tree
        (Node (Leaf nat) 0 (Leaf nat))
        (Node (Leaf nat) 0 (Leaf nat)).
Proof. simpl; auto. Qed.

Theorem thm3 :
    isomorphic_tree
        (Node (Leaf nat) 0 (Leaf nat))
        (Node (Leaf nat) 1 (Leaf nat)).
Proof. simpl; auto. Qed.

Theorem thm4 :
    ~isomorphic_tree
        (Leaf nat)
        (Node (Leaf nat) 1 (Leaf nat)).
Proof. simpl; intro H; inversion H. Qed.

Theorem thm5 :
    ~isomorphic_tree
        (Node (Node (Leaf nat) 0 (Leaf nat)) 1 (Leaf nat))
        (Node (Leaf nat) 1 (Node (Leaf nat) 0 (Leaf nat))).
Proof. simpl; intuition. Qed.

End Structural_Induction_on_Trees.
End Primitive_Recursion_and_Structural_Induction.

(* HACK: have to redo this since we closed the section. *)
Implicit Arguments Node [A].


(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ *)
Section Inductive_Definitions.

(* N.B., we could easily generalize this to work for any type [A]
   with a decidable equality. *)
Fixpoint keys (T : tree nat) : set nat :=
    match T with
    | Leaf       => empty_set nat
    | Node L x R =>
        set_union eq_nat_dec
            (keys L)
            (set_union eq_nat_dec
                (set_add eq_nat_dec x (empty_set nat))
                (keys R))
    end.


(* N.B., Isabelle's inductive predicates (defined by using the
[inductive] keyword) are the same as Coq's indexed data types.
Isabelle's inductive sets (defined by using the [inductive_set]
keyword) are essentially the same thing, but with some syntactic
sugar so we can say ["T \<in> BST"] instead of ["BST T"]. In order
to get the equivalent of Isabelle's ["BST"] set, we would use the
[{T : tree nat | BST T}] type in Coq. That is,

    inductive BST_pred :: "nat tree => bool" where
        bst_leaf: "BST_pred Leaf" |
        bst_node:
            "[| ALL y:keys L. y <= x
              ; ALL z:keys R. x <= z
              ; BST_pred L
              ; BST_pred R
              |] ==> BST_pred (Node L x R)"

    (* Literal translation of Coq's [BST_set], defined below *)
    inductive_set BST_set :: "(nat tree) set" where
        bst: "BST_pred T ==> T:BST_set"
    
    (* More natural definition in Isabelle *)
    inductive_set BST_set :: "(nat tree) set" where
        bst_leaf: "Leaf:BST_set" |
        bst_node:
            "[| ALL y:keys L. y <= x
              ; ALL z:keys R. x <= z
              ; L:BST_set
              ; R:BST_set
              |] ==> (Node L x R):BST_set"

    
    Inductive BST_pred : tree nat -> Set :=
        | bst_leaf : BST_pred (Leaf nat)
        | bst_node :
            forall {L x R},
            (forall y, In y (keys L) -> y <= x) ->
            (forall z, In z (keys R) -> x <= z) ->
            BST_pred L ->
            BST_pred R ->
            BST_pred (Node L x R)
        .

    Definition BST_set := { T : tree nat | BST_pred T }.
    
In terms of the Coq syntax, note that parametric arguments appear
to the left of the colon (as shown above with the definition of
[tree]) whereas indexed arguments appear to the right of the colon
(as seen below). This looks subtle, but be sure not to get them
mixed up! *)

Inductive BST : tree nat -> Set :=
    | bst_leaf : BST (Leaf nat)
    | bst_node :
        forall {L x R},
        (forall y, In y (keys L) -> y <= x) ->
        (forall z, In z (keys R) -> x <= z) ->
        BST L ->
        BST R ->
        BST (Node L x R)
    .

    
Fixpoint bst_insert (x : nat) (t : tree nat) : tree nat :=
    match t with
    | Leaf       => Node (Leaf nat) x (Leaf nat)
    | Node L y R =>
        if lt_dec x y
        then Node (bst_insert x L) y R
        else
            if lt_dec y x
            then Node L y (bst_insert x R)
            else Node L y R
    end.

Definition set_equiv {A} xs ys := forall x:A, set_In x xs <-> set_In x ys.

Lemma insert_keys
    : forall x t,
    set_equiv (keys (bst_insert x t)) (set_add eq_nat_dec x (keys t)).
Proof.
    intros; induction t; simpl.
      intro; split; simpl; auto.
      
      destruct (lt_dec x a); simpl; auto.
      (* TODO: finish this *)
Abort.


Lemma insert_bst_helper:
    forall t x y, In x (keys (bst_insert y t)) -> x = y \/ In x (keys t).
Proof.
  intro t; induction t; simpl; intros x y H.
    destruct H; auto.
    
    destruct (lt_dec y a).
      admit. (* TODO *)
      
      admit. (* TODO *)
Qed.
    
   
Theorem insert_bst : forall x T, BST T -> BST (bst_insert x T).
Proof.
  intros x T T_bst.
  induction T_bst as [| L y R IHL IHR L_bst Lx_bst R_bst Rx_bst]; simpl.
    constructor; solve [simpl; contradiction | constructor].
    
    destruct (lt_dec x y) as [x_lt_y | y_le_x].
      constructor; auto.
      intros z Hz.
      destruct (insert_bst_helper L z x Hz);
        [ apply lt_le_weak; congruence
        | apply IHL; assumption
        ].
      
      destruct (lt_dec y x) as [y_lt_x | x_le_y]; constructor; auto.
      intros z Hz.
      destruct (insert_bst_helper R z x Hz);
        [ apply lt_le_weak; congruence
        | apply IHR; assumption
        ].
Qed.


Fixpoint search (t : tree nat) (x : nat) : Prop :=
    match t with
    | Leaf       => False
    | Node L y R =>
        if lt_dec x y
        then search L x
        else
            if lt_dec y x
            then search R x
            else True
    end.
 
End Inductive_Definitions.
End Chapter1.
(* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ fin. *)
